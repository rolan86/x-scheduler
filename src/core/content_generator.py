"""AI-powered content generation service."""

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime

from src.api.openai_client import openai_client
from src.models import get_db, StyleTemplate, UserSettings, SettingCategory
from src.core.database import get_setting
from src.core.tweet_manager import tweet_manager


logger = logging.getLogger(__name__)


class ContentGenerator:
    """Generates tweet content using AI with style matching."""
    
    def __init__(self):
        pass
    
    def generate_tweets(self, topic: str, style: str = "personal", count: int = 1,
                       model: str = "gpt-4", save_to_db: bool = True) -> List[Dict[str, Any]]:
        """Generate tweet content about a topic."""
        try:
            # Get AI settings
            temperature = get_setting(SettingCategory.AI, "temperature", 0.7)
            include_hashtags = get_setting(SettingCategory.AI, "include_hashtags", True)
            hashtag_count = get_setting(SettingCategory.AI, "hashtag_count", 3)
            
            # Generate content using OpenAI
            generated_tweets = openai_client.generate_tweet_content(
                prompt=topic,
                style=style,
                model=model,
                count=count
            )
            
            if not generated_tweets:
                logger.error("No tweets generated by OpenAI")
                return []
            
            results = []
            
            for tweet_data in generated_tweets:
                content = tweet_data['content']
                
                # Post-process content
                if include_hashtags and not self._has_hashtags(content):
                    content = self._add_hashtags(content, topic, hashtag_count)
                
                # Validate content length
                if len(content) > 280:
                    content = self._truncate_content(content)
                
                # Save to database if requested
                tweet_id = None
                if save_to_db:
                    try:
                        from src.models import ContentType
                        content_type = ContentType(style) if style in [ct.value for ct in ContentType] else ContentType.PERSONAL
                        
                        tweet = tweet_manager.create_tweet(
                            content=content,
                            content_type=content_type,
                            ai_generated=True,
                            generation_prompt=topic,
                            generation_model=model,
                            generation_cost=tweet_data['cost']
                        )
                        tweet_id = tweet.id
                        logger.info(f"Saved generated tweet to database: {tweet_id}")
                    except Exception as e:
                        logger.error(f"Failed to save tweet to database: {e}")
                
                result = {
                    'id': tweet_id,
                    'content': content,
                    'original_content': tweet_data['content'],
                    'topic': topic,
                    'style': style,
                    'model': model,
                    'cost': tweet_data['cost'],
                    'tokens_used': tweet_data['tokens_used'],
                    'character_count': len(content),
                    'has_hashtags': self._has_hashtags(content),
                    'hashtag_count': self._count_hashtags(content),
                    'created_at': datetime.now().isoformat(),
                    'index': tweet_data['index']
                }
                
                results.append(result)
            
            logger.info(f"Generated {len(results)} tweets for topic '{topic}' in {style} style")
            return results
            
        except Exception as e:
            logger.error(f"Failed to generate tweets: {e}")
            return []
    
    def generate_with_template(self, topic: str, template_name: str, count: int = 1,
                             save_to_db: bool = True) -> List[Dict[str, Any]]:
        """Generate tweets using a style template."""
        try:
            db = next(get_db())
            
            # Get template
            template = db.query(StyleTemplate).filter_by(name=template_name, is_active=True).first()
            db.close()
            
            if not template:
                logger.error(f"Style template '{template_name}' not found")
                return []
            
            # Create enhanced prompt based on template
            enhanced_prompt = self._create_template_prompt(topic, template)
            
            # Use template's tone as style
            style = template.tone
            
            # Generate content
            results = self.generate_tweets(
                topic=enhanced_prompt,
                style=style,
                count=count,
                save_to_db=save_to_db
            )
            
            # Update template usage
            try:
                db = next(get_db())
                template.times_used += 1
                db.commit()
                db.close()
            except Exception as e:
                logger.error(f"Failed to update template usage: {e}")
            
            return results
            
        except Exception as e:
            logger.error(f"Failed to generate with template: {e}")
            return []
    
    def _create_template_prompt(self, topic: str, template: StyleTemplate) -> str:
        """Create an enhanced prompt based on style template."""
        prompt_parts = [topic]
        
        # Add tone and voice guidance
        prompt_parts.append(f"Use a {template.tone} tone with a {template.voice} voice.")
        
        # Add vocabulary level guidance
        vocab_guidance = {
            "simple": "Use simple, everyday language that anyone can understand.",
            "medium": "Use clear, accessible language with some technical terms when appropriate.",
            "advanced": "Use sophisticated vocabulary and complex concepts."
        }
        prompt_parts.append(vocab_guidance.get(template.vocabulary_level, vocab_guidance["medium"]))
        
        # Add emoji guidance
        if template.use_emojis:
            emoji_guidance = {
                0.1: "Use emojis sparingly",
                0.2: "Use a few relevant emojis",
                0.3: "Use emojis moderately",
                0.4: "Use emojis frequently"
            }
            closest_freq = min(emoji_guidance.keys(), key=lambda x: abs(x - template.emoji_frequency))
            prompt_parts.append(emoji_guidance[closest_freq])
        else:
            prompt_parts.append("Do not use emojis.")
        
        # Add hashtag guidance
        if template.use_hashtags:
            hashtag_style_guidance = {
                "lowercase": "Include relevant hashtags in lowercase",
                "CamelCase": "Include relevant hashtags in CamelCase format",
                "UPPERCASE": "Include relevant hashtags in UPPERCASE"
            }
            prompt_parts.append(hashtag_style_guidance.get(template.hashtag_style, hashtag_style_guidance["lowercase"]))
        
        # Add opening/closing patterns if available
        if template.opening_patterns:
            prompt_parts.append(f"Consider starting with phrases like: {', '.join(template.opening_patterns[:3])}")
        
        if template.closing_patterns:
            prompt_parts.append(f"Consider ending with phrases like: {', '.join(template.closing_patterns[:3])}")
        
        return " ".join(prompt_parts)
    
    def _has_hashtags(self, content: str) -> bool:
        """Check if content contains hashtags."""
        return '#' in content
    
    def _count_hashtags(self, content: str) -> int:
        """Count hashtags in content."""
        return content.count('#')
    
    def _add_hashtags(self, content: str, topic: str, max_hashtags: int = 3) -> str:
        """Add relevant hashtags to content."""
        # Simple hashtag generation based on topic
        topic_words = topic.lower().split()
        hashtags = []
        
        for word in topic_words:
            if len(word) > 3 and word.isalpha():
                hashtag = f"#{word}"
                if hashtag not in hashtags:
                    hashtags.append(hashtag)
                if len(hashtags) >= max_hashtags:
                    break
        
        if hashtags:
            hashtag_text = " " + " ".join(hashtags)
            # Check if adding hashtags would exceed character limit
            if len(content + hashtag_text) <= 280:
                content += hashtag_text
        
        return content
    
    def _truncate_content(self, content: str, max_length: int = 280) -> str:
        """Truncate content to fit character limit."""
        if len(content) <= max_length:
            return content
        
        # Try to truncate at word boundary
        truncated = content[:max_length]
        
        # Find last space before the limit
        last_space = truncated.rfind(' ')
        if last_space > max_length * 0.8:  # Only truncate at word if it's not too short
            truncated = truncated[:last_space]
        
        # Add ellipsis if we truncated
        if len(truncated) < len(content):
            truncated = truncated.rstrip() + "..."
        
        return truncated
    
    def analyze_content_style(self, text_samples: List[str]) -> Optional[Dict[str, Any]]:
        """Analyze writing style from text samples."""
        try:
            if not text_samples:
                logger.error("No text samples provided for analysis")
                return None
            
            analysis = openai_client.analyze_writing_style(text_samples)
            
            if analysis:
                logger.info(f"Analyzed writing style for {len(text_samples)} samples")
                return analysis
            else:
                logger.error("Failed to analyze writing style")
                return None
                
        except Exception as e:
            logger.error(f"Error analyzing content style: {e}")
            return None
    
    def create_style_template(self, name: str, description: str, text_samples: List[str]) -> bool:
        """Create a new style template based on text analysis."""
        try:
            # Analyze the text samples
            analysis = self.analyze_content_style(text_samples)
            
            if not analysis:
                logger.error("Failed to analyze style for template creation")
                return False
            
            db = next(get_db())
            
            # Check if template already exists
            existing = db.query(StyleTemplate).filter_by(name=name).first()
            if existing:
                logger.error(f"Style template '{name}' already exists")
                db.close()
                return False
            
            # Create template
            template = StyleTemplate(
                name=name,
                description=description,
                tone=analysis.get('tone', 'conversational'),
                voice=analysis.get('voice', 'friendly'),
                opening_patterns=analysis.get('common_phrases', [])[:5],
                closing_patterns=[],  # Would need more sophisticated analysis
                vocabulary_level=analysis.get('vocabulary_level', 'medium'),
                sentence_structure=analysis.get('sentence_structure', 'varied'),
                use_emojis=analysis.get('emoji_usage', 'none') != 'none',
                emoji_frequency=0.2 if analysis.get('emoji_usage', 'none') != 'none' else 0.0,
                use_hashtags=analysis.get('hashtag_style', 'none') != 'none',
                hashtag_style=analysis.get('hashtag_style', 'lowercase'),
                example_tweets=text_samples[:3]  # Store first 3 as examples
            )
            
            db.add(template)
            db.commit()
            db.close()
            
            logger.info(f"Created style template '{name}'")
            return True
            
        except Exception as e:
            logger.error(f"Failed to create style template: {e}")
            return False
    
    def get_style_templates(self) -> List[Dict[str, Any]]:
        """Get all available style templates."""
        try:
            db = next(get_db())
            templates = db.query(StyleTemplate).filter_by(is_active=True).all()
            
            result = []
            for template in templates:
                template_data = {
                    'id': template.id,
                    'name': template.name,
                    'description': template.description,
                    'tone': template.tone,
                    'voice': template.voice,
                    'vocabulary_level': template.vocabulary_level,
                    'use_emojis': template.use_emojis,
                    'use_hashtags': template.use_hashtags,
                    'times_used': template.times_used,
                    'created_at': template.created_at.isoformat()
                }
                result.append(template_data)
            
            db.close()
            return result
            
        except Exception as e:
            logger.error(f"Failed to get style templates: {e}")
            return []
    
    def get_generation_stats(self) -> Dict[str, Any]:
        """Get content generation statistics."""
        try:
            from src.models import Tweet
            
            db = next(get_db())
            
            # Count AI generated tweets
            total_ai_tweets = db.query(Tweet).filter_by(ai_generated=True).count()
            
            # Count by content type
            content_type_counts = {}
            for content_type in ['personal', 'professional', 'casual', 'educational']:
                count = db.query(Tweet).filter_by(ai_generated=True).filter(
                    Tweet.content_type == content_type
                ).count()
                content_type_counts[content_type] = count
            
            # Total generation cost
            from sqlalchemy import func
            total_cost = db.query(func.sum(Tweet.generation_cost)).filter_by(ai_generated=True).scalar() or 0.0
            
            db.close()
            
            stats = {
                'total_ai_generated': total_ai_tweets,
                'content_type_breakdown': content_type_counts,
                'total_generation_cost': round(total_cost, 4),
                'average_cost_per_tweet': round(total_cost / total_ai_tweets, 4) if total_ai_tweets > 0 else 0.0
            }
            
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get generation stats: {e}")
            return {}


# Global content generator instance
content_generator = ContentGenerator()